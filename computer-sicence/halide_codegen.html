<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halide DSL - 代码生成与优化</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 900px; margin: 0 auto; padding: 20px; }
        h1 { color: #333; }
        h2 { color: #555; margin-top: 30px; }
        .qa { background: #f9f9f9; padding: 15px; margin: 15px 0; border-left: 4px solid #007bff; }
        .answer { color: #28a745; font-weight: bold; }
        .description { margin-top: 10px; color: #333; }
        ul { margin: 10px 0; }
        li { margin: 8px 0; }
        code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>Halide DSL - 代码生成与优化</h1>
    
    <div class="qa">
        <h2>Halide 是 DSL 吗？</h2>
        <p class="answer">✅ 是的。</p>
        <div class="description">
            <p>Halide 是专为 <strong>图像处理与数值计算</strong> 设计的 DSL，它的理念是：</p>
            
            <h3>核心设计理念</h3>
            <ul>
                <li><strong>算法层（Algorithm）</strong>：只描述计算逻辑，比如卷积、模糊、锐化</li>
                <li><strong>调度层（Schedule）</strong>：描述如何执行，比如并行化、向量化、分块、存储位置</li>
            </ul>
            
            <h3>优势</h3>
            <p>这样的设计使得：</p>
            <ul>
                <li>算法可以保持数学纯净</li>
                <li>调度部分可以单独针对硬件优化</li>
                <li>同一算法可以轻松适配不同的硬件平台（CPU、GPU、移动设备等）</li>
                <li>性能优化与算法逻辑解耦</li>
            </ul>
        </div>
    </div>
    
    <div class="qa">
        <h2>Halide 代码生成管道（CPU & GPU）</h2>
        <div class="description">
            <p>Halide 统一的代码生成流程，支持 CPU 和 GPU 目标：</p>
            <pre style="background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto;">
算法定义（Halide DSL）
   ↓
调度搜索 + 代价模型（Cost Model）
   ↓
Halide IR 优化（Loop nest / Vectorize / Parallelize）
   ↓
   ├─── CPU 路径 ────────────────┬─── GPU 路径 ──────────────┐
   ↓                              ↓
LLVM IR 生成                 Lower to GPU Kernel IR
（调用 LLVM API）            （Halide 内部 GPUIR）
   ↓                              ↓
机器码                        生成 OpenCL C 源码字符串
（x86 / ARM / NEON）         （kernel）
                                  ↓
                             OpenCL Runtime API 编译
                             （clBuildProgram）
                                  ↓
                             GPU 二进制代码
            </pre>
            
            <h3>共同阶段</h3>
            <ul>
                <li><strong>算法定义</strong>：用户用 Halide DSL 描述计算</li>
                <li><strong>调度搜索</strong>：根据代价模型找到最优的执行策略</li>
                <li><strong>Halide IR 优化</strong>：
                    <ul>
                        <li>Loop nest：嵌套循环结构优化</li>
                        <li>Vectorize：向量化</li>
                        <li>Parallelize：并行化</li>
                    </ul>
                </li>
            </ul>
            
            <h3>CPU 特定阶段</h3>
            <ul>
                <li><strong>LLVM IR 生成</strong>：将 Halide IR 转换为 LLVM 中间表示，调用 LLVM API</li>
                <li><strong>机器码生成</strong>：针对不同架构（x86、ARM、NEON等）生成优化后的机器码</li>
            </ul>
            
            <h3>GPU 特定阶段</h3>
            <ul>
                <li><strong>Lower to GPU Kernel IR</strong>：
                    <ul>
                        <li>将 Halide IR 转化为 GPU 友好的内部中间表示</li>
                        <li>进行 GPU 特定的优化（分线程块、线程、内存层级等）</li>
                    </ul>
                </li>
                <li><strong>生成 OpenCL C 源码</strong>：
                    <ul>
                        <li>从 GPU Kernel IR 生成 OpenCL C 源代码字符串</li>
                        <li>包含 kernel 函数和内存访问模式</li>
                    </ul>
                </li>
                <li><strong>OpenCL 编译运行</strong>：
                    <ul>
                        <li>通过 OpenCL Runtime API 调用 <code>clBuildProgram</code> 编译源码</li>
                        <li>获得 GPU 二进制代码</li>
                        <li>在运行时加载并执行</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    
    <div class="qa">
        <h2>Halide 算法优化策略</h2>
        <div class="description">
            <p>Halide 的算法优化思想融合了 <strong>编译优化理论</strong> 和 <strong>自动调度（auto-scheduler）算法</strong>，主要包括：</p>
            
            <h3>主要优化策略对比</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <tr style="background: #e8f4f8; border-bottom: 2px solid #007bff;">
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">优化策略</th>
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">理论依据</th>
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">实现效果</th>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Loop Tiling</strong>（循环分块）</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">空间/时间局部性</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">减少 cache miss</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Vectorization</strong>（向量化）</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">SIMD 理论</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">提升并行吞吐率</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Parallelization</strong>（多线程）</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">Fork-Join Model</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">CPU 多核利用</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Fusing/Splitting</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">DAG 节点融合</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">减少中间内存</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Storage Folding</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">数据重用</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">减少带宽压力</td>
                </tr>
                <tr style="background: #f0f8ff;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>Auto-scheduler</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">代价模型 + 搜索</td>
                    <td style="padding: 10px; border: 1px solid #ddd;">自动找到最优调度策略</td>
                </tr>
            </table>
            
            <h3>代价模型（Cost Model）</h3>
            <p>Halide 的 auto-scheduler 基于一个 <strong>代价函数模型</strong>：</p>
            <div style="background: #f9f9f9; padding: 15px; margin: 15px 0; border-radius: 5px; border-left: 4px solid #007bff;">
                <p><strong>代价函数：</strong></p>
                <p><code>C(S) = α · memory_access(S) + β · compute(S) + γ · parallel_overhead(S)</code></p>
                <p style="margin-top: 10px; font-size: 0.9em;">其中：</p>
                <ul style="margin: 5px 0; font-size: 0.9em;">
                    <li><code>memory_access(S)</code>：内存访问成本（受缓存局部性影响）</li>
                    <li><code>compute(S)</code>：计算成本（指令数、向量化程度等）</li>
                    <li><code>parallel_overhead(S)</code>：并行化开销（线程同步、通信等）</li>
                    <li><code>α, β, γ</code>：各项的权重系数（根据硬件特性调整）</li>
                </ul>
            </div>
            
            <h3>自动调度搜索</h3>
            <p>通过搜索找到最优的调度策略：</p>
            <pre style="background: #f4f4f4; padding: 15px; border-radius: 5px; overflow-x: auto;">
S* = argmin(C(S))   // 找到使代价函数最小的调度 S*

搜索空间包括：
  - Loop order（循环顺序）
  - Tiling factors（分块大小）
  - Parallelization level（并行化粒度）
  - Vectorization width（向量宽度）
  - Storage location（存储位置）
  - Fusion/Split decisions（融合/分割决策）
            </pre>
            
            <h3>不同自动调度库的优化方向</h3>
            <ul>
                <li><strong>Mullapudi 2016</strong>：基于随机森林学习历史性能数据，直接预测最优调度</li>
                <li><strong>Li 2018</strong>：改进的特征工程，更好的泛化到新的计算模式</li>
                <li><strong>Adams 2019</strong>：使用深度学习代价模型，更精准的性能预测，搜索策略更高效</li>
            </ul>
        </div>
    </div>

    <div class="qa">
        <h2>RK3588 实战经验 (1) - GPU自动调度器（Adams 2019）</h2>
        <div class="description">
            <p>Adams 2019 是 Halide 中最先进的自动调度器，位于 Halide 源码路径：<code>src/Autoscheduler/Adams2019</code></p>
            
            <h3>调度策略：两个代价模型</h3>
            <ul>
                <li><strong>CPU Cost Model</strong>
                    <ul>
                        <li>基于深度神经网络学习 CPU 性能特征</li>
                        <li>输入特征：loop nest 结构、内存访问模式、并行化策略等</li>
                        <li>输出：执行时间预测</li>
                        <li>RK3588 CPU 架构：4×A76 + 4×A55 混合核心，模型需要适配大小核差异</li>
                    </ul>
                </li>
                <li><strong>GPU Cost Model（实验性）</strong>
                    <ul>
                        <li>训练数据主要来自 NVIDIA GPU（CUDA 优化的数据）</li>
                        <li>RK3588 搭载 Mali-G610 GPU，与 NVIDIA 架构差异较大</li>
                        <li>泛化性受限：OpenCL 与 CUDA 的计算模型、内存层级、warp/workgroup 调度机制不同</li>
                        <li>建议在 RK3588 实际部署时，使用 CPU model 或针对 Mali-G610 重新训练 GPU model</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <div class="qa">
        <h2>RK3588 实战经验 (2) - GPU手动调度 malloc_consolidate() 崩溃问题</h2>
        <div class="description">
            <h3>错误现象</h3>
            <p>在 ARM Mali GPU 上使用 Halide 手动调度进行 GPU 计算时，程序崩溃并输出：</p>
            <pre style="background: #f9f9f9; padding: 15px; border-radius: 5px; overflow-x: auto; color: #d32f2f;">
malloc_consolidate(): invalid chunk size
Aborted (core dumped)
            </pre>
            
            <h3>根本原因</h3>
            <p>这个错误 <strong>不是 Halide 算法本身崩溃</strong>，而是：</p>
            <ul>
                <li><strong>OpenCL runtime（libmali）</strong> 在 Halide AOT（Ahead-of-Time）编译模式下释放内存时出现问题</li>
                <li>具体表现为 <strong>二次释放（double free）</strong>：内存被释放两次，导致堆损坏</li>
                <li>这是 <strong>Halide OpenCL runtime 在 ARM Mali 上的已知 bug</strong></li>
                <li>在 libHalide.so < v17 版本中最为常见</li>
            </ul>

            <h3>问题分析</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <tr style="background: #e8f4f8; border-bottom: 2px solid #007bff;">
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">问题环节</th>
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">详细说明</th>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>发生阶段</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">程序结束或 GPU buffer 释放时（析构函数）</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>涉及组件</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">libmali（ARM Mali OpenCL driver）、libHalide.so OpenCL backend</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>关键因素</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">AOT 编译时的内存管理逻辑与 libmali 的释放机制不兼容</td>
                </tr>
                <tr style="background: #f0f8ff;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>触发条件</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">手动调度 GPU 任务 + 大尺寸 buffer（>32MB）+ 频繁分配/释放</td>
                </tr>
            </table>
        </div>
    </div>

    <div class="qa">
        <h2>RK3588 实战经验 (3) - CPU自动调度 machine_params 最优配置计算</h2>
        <div class="description">
            <p>基于 RK3588 的硬件规格，为 4 个 A76 大核计算最优的 <code>machine_params</code> 设置。</p>
            
            <h3>RK3588 A76 大核规格</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <tr style="background: #e8f4f8; border-bottom: 2px solid #007bff;">
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">硬件参数</th>
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">规格</th>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>CPU 型号</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">ARM Cortex-A76（4 核）</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>主频</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">2.4 GHz</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>L1 缓存</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">32KB (Instruction) + 32KB (Data) = 64KB / 核</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>L2 缓存</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">1MB / 核（4 核共 4MB）</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>L3 缓存</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">4MB（系统级共享，所有核心共用）</td>
                </tr>
                <tr style="background: #f0f8ff;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>总缓存容量</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">L2 (4MB) + L3 (4MB) = <strong>8MB</strong></td>
                </tr>
            </table>

            <h3>machine_params 三参数计算</h3>
            <ol style="margin: 10px 0;">
                <li><strong>cores = 4</strong>
                    <ul>
                        <li>使用 4 个 A76 大核</li>
                        <li>通过 Linux cpuset 或 taskset 隔离小核</li>
                    </ul>
                </li>
                <li><strong>memory_size 计算</strong>
                    <ul>
                        <li>代价模型评估数据在缓存中的重用性</li>
                        <li>推荐值：<strong>L2 + L3 缓存总和 = 8MB = 8388608 Bytes</strong></li>
                        <li>保守策略：使用 L3 容量 4MB = 4194304 Bytes（避免 L2 竞争）</li>
                        <li>激进策略：使用 8MB（允许充分利用 L2 缓存）</li>
                    </ul>
                </li>
                <li><strong>compute_capability 计算</strong>
                    <ul>
                        <li>相对基准处理器的性能系数</li>
                        <li>A76 @ 2.4GHz 的计算能力通常为基准的 <strong>40-50 倍</strong></li>
                        <li>更精确计算：基于 A76 指令集和 SIMD 能力
                            <ul>
                                <li>A76 支持 NEON（128-bit SIMD），每周期可执行 2 条 FP32 指令</li>
                                <li>相对基准单线程处理器，性能系数约 <strong>45-50</strong></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ol>

            <h3>推荐配置方案</h3>
            <table style="width: 100%; border-collapse: collapse; margin: 15px 0;">
                <tr style="background: #e8f4f8; border-bottom: 2px solid #007bff;">
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">配置方案</th>
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">machine_params</th>
                    <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">适用场景</th>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>保守方案</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;"><code>4,4194304,45</code></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">只考虑 L3 缓存，避免 L2 竞争，适合复杂算法</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>平衡方案（推荐）</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;"><code>4,8388608,48</code></td>
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>最优选择</strong>：充分利用 L2+L3，性能预测最准确</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>激进方案</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;"><code>4,8388608,50</code></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">充分利用大核性能，追求最大吞吐量</td>
                </tr>
                <tr style="background: #f0f8ff;">
                    <td style="padding: 10px; border: 1px solid #ddd;"><strong>原始参考</strong></td>
                    <td style="padding: 10px; border: 1px solid #ddd;"><code>4,16777216,40</code></td>
                    <td style="padding: 10px; border: 1px solid #ddd;">原始 16MB 设置偏大（超出实际缓存），compute_capability 偏低</td>
                </tr>
            </table>

            <h3>详细分析</h3>
            <p><strong>为何推荐 4,8388608,48？</strong></p>
            <ul>
                <li><strong>cores=4</strong>：只用 A76 大核，避免小核的不规则性</li>
                <li><strong>memory_size=8388608</strong>（8MB）：
                    <ul>
                        <li>等于 L2 + L3 总容量，代价模型会优化数据重用</li>
                        <li>避免频繁访问主内存（DDR，延迟 ~100ns）</li>
                        <li>充分利用 A76 的缓存预取能力</li>
                    </ul>
                </li>
                <li><strong>compute_capability=48</strong>：
                    <ul>
                        <li>A76 @ 2.4GHz 的相对性能系数</li>
                        <li>基于：双发射 NEON FP32（每周期 2 ops）× 2.4GHz × SIMD 宽度</li>
                        <li>相对基准单线程处理器的性能倍数约 48 倍</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
    
</body>
</html>