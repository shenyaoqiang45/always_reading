<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenCL 源码编译</title>
    <style>
        body {
            font-family: "Microsoft YaHei", SimHei, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #ecf0f1;
        }
        .check-mark {
            color: #27ae60;
            font-weight: bold;
        }
        .code {
            background-color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .description {
            color: #555;
            font-size: 0.95em;
        }
        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 3px;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 2px 4px;
        }
        pre.diagram {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .vendor-table {
            margin: 20px 0;
        }
        .vendor-table th {
            background-color: #e74c3c;
        }
        .driver-table th {
            background-color: #27ae60;
        }
    </style>
</head>
<body>
    <h1>OpenCL 源码编译的两种情况</h1>
    
    <table>
        <thead>
            <tr>
                <th>编译阶段</th>
                <th>谁来编译</th>
                <th>是否用到 LLVM</th>
                <th>说明</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>① OpenCL Host 代码（C/C++）</strong></td>
                <td>开发者用 GCC / Clang 编译</td>
                <td><span class="check-mark">✅</span> 如果用 Clang，则内部使用 LLVM；GCC 则否</td>
                <td class="description">这是你在主机端写的控制程序，例如 <span class="code">clCreateKernel()</span>、<span class="code">clEnqueueNDRangeKernel()</span> 调用</td>
            </tr>
            <tr>
                <td><strong>② OpenCL Kernel 代码（内核字符串）</strong></td>
                <td>运行时由 OpenCL Driver 编译</td>
                <td><span class="check-mark">✅</span> 通常内部实现使用 LLVM 前端</td>
                <td class="description">例如 <span class="code">__kernel void add(...) {...}</span>，由驱动在运行时编译成 GPU ISA</td>
            </tr>
        </tbody>
    </table>

    <div class="note">
        <strong>💡 关键要点：</strong>
        <ul>
            <li><strong>Host 代码</strong>：由你的编译器（GCC 或 Clang）编译成 CPU 可执行代码</li>
            <li><strong>Kernel 代码</strong>：由 OpenCL 驱动在运行时动态编译成 GPU ISA 指令</li>
            <li><strong>LLVM 的角色</strong>：在两个阶段都可能出现，但方式不同</li>
        </ul>
    </div>

    <h2>编译流程示意图</h2>
    <pre class="diagram">
┌─────────────────────────────────────────────────────────────┐
│                    开发者源代码                              │
├─────────────────────────────────────────────────────────────┤
│  ① Host Code (C/C++)          │  ② Kernel Code (OpenCL C)  │
│  - clCreateKernel()           │  - __kernel void add()     │
│  - clEnqueueNDRangeKernel()  │  - 字符串形式传给驱动      │
└──────────────────┬────────────┴──────────────────┬──────────┘
                   │                               │
        ┌──────────▼────────────┐      ┌──────────▼──────────┐
        │  GCC / Clang 编译器   │      │  OpenCL 驱动编译    │
        │  (开发者本地编译)     │      │  (运行时编译)       │
        └──────────┬────────────┘      └──────────┬──────────┘
                   │                               │
        ┌──────────▼────────────┐      ┌──────────▼──────────┐
        │  CPU 可执行文件       │      │  GPU ISA 代码       │
        │  (主机程序)          │      │  (GPU 机器指令)     │
        └──────────────────────┘      └─────────────────────┘
    </pre>

    <h2>二、libOpenCL.so 是什么？它的真实角色</h2>

    <div class="note">
        <strong>⚠️ 常见误解：libOpenCL.so 不是完整的 GPU 驱动！</strong><br/>
        libOpenCL.so 是 <strong>OpenCL Runtime / ICD Loader</strong>，它只是一个中间层，
        真正控制 GPU 并 JIT 编译 kernel 的是<strong>厂商底层的 OpenCL Driver</strong>。
    </div>

    <h3>2.1 libOpenCL.so 的真实角色</h3>

    <table class="vendor-table">
        <thead>
            <tr>
                <th>组件名称</th>
                <th>功能</th>
                <th>谁提供</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>libOpenCL.so</strong><br/>(OpenCL Loader)</td>
                <td>提供标准 OpenCL API 接口（<span class="code">clCreateKernel()</span>、<span class="code">clEnqueueNDRangeKernel()</span> 等）给应用程序调用</td>
                <td>Khronos 标准实现 / 各平台发行</td>
            </tr>
            <tr>
                <td><strong>ICD (Installable Client Driver)</strong><br/>(动态加载机制)</td>
                <td>扫描系统中已安装的 GPU 驱动，动态加载硬件厂商提供的 OpenCL 实现库（Vendor Driver），把 API 调用路由到对应 GPU</td>
                <td>Khronos ICD 标准规范</td>
            </tr>
            <tr>
                <td><strong>Vendor OpenCL Driver</strong><br/>(例：libcuda.so / libamdgpu-core.so)</td>
                <td>真正实现 OpenCL 功能：JIT 编译 kernel、管理 GPU 内存、调度执行</td>
                <td>NVIDIA / AMD / Intel / ARM 等硬件厂商</td>
            </tr>
        </tbody>
    </table>

    <h3>2.2 架构图：libOpenCL.so 与厂商驱动的关系</h3>

    <pre class="diagram">
┌─────────────────────────────────────────────────────────────┐
│              你的 OpenCL Host 应用程序                      │
│  (使用 clCreateKernel、clEnqueueNDRangeKernel 等 API)      │
└──────────────────────┬──────────────────────────────────────┘
                       │
        ┌──────────────▼───────────────┐
        │   libOpenCL.so               │
        │  (OpenCL Runtime / Loader)   │
        │                              │
        │  ✓ 提供标准 API 接口         │
        │  ✓ 管理 ICD 插件加载         │
        │  ✓ 路由 API 调用             │
        └──────────────┬───────────────┘
                       │
        ┌──────────────▼─────────────────────────┐
        │     ICD Plugin Loader                  │
        │  (扫描系统中的 GPU 驱动库)             │
        └──────────────┬─────────────────────────┘
                       │
        ┌──────────────────────────────────────────────────────┐
        │ 根据检测到的硬件，动态加载对应厂商驱动              │
        └─┬─────────────────────┬──────────────────┬──────────┘
          │                     │                  │
  ┌───────▼───────┐  ┌────────▼────────┐  ┌──────▼──────┐
  │ NVIDIA 驱动   │  │   AMD 驱动     │  │ Intel 驱动  │
  │ libcuda.so    │  │libamdgpu-core   │  │ libigc.so   │
  │               │  │                 │  │             │
  │ ✓ JIT 编译    │  │ ✓ JIT 编译     │  │ ✓ JIT 编译 │
  │ ✓ GPU 内存    │  │ ✓ GPU 内存     │  │ ✓ GPU 内存 │
  │ ✓ 任务调度    │  │ ✓ 任务调度     │  │ ✓ 任务调度 │
  └────────┬──────┘  └────────┬────────┘  └──────┬──────┘
           │                  │                   │
  ┌────────▼──────────────────▼───────────────────▼────┐
  │            GPU 硬件执行                            │
  │   (SASS、GCN ISA、Gen ISA ...)                     │
  └──────────────────────────────────────────────────────┘
    </pre>

    <h3>2.3 ICD 加载机制的工作流程</h3>

    <table>
        <thead>
            <tr>
                <th>步骤</th>
                <th>发生地点</th>
                <th>具体操作</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>① 应用启动</strong></td>
                <td>Host 程序</td>
                <td>你的程序调用 <span class="code">clGetPlatformIDs()</span></td>
            </tr>
            <tr>
                <td><strong>② libOpenCL.so 初始化</strong></td>
                <td>libOpenCL.so</td>
                <td>libOpenCL.so 加载到内存，开始 ICD 扫描</td>
            </tr>
            <tr>
                <td><strong>③ 扫描系统驱动</strong></td>
                <td>ICD Loader</td>
                <td>查找 <span class="code">/etc/OpenCL/vendors/</span> 或 Windows 注册表中的驱动列表</td>
            </tr>
            <tr>
                <td><strong>④ 动态加载 Vendor Driver</strong></td>
                <td>ICD Loader</td>
                <td>使用 dlopen() 加载 NVIDIA/AMD/Intel 的 OpenCL 库<br/>
                    例：<span class="code">dlopen("libnvidia-opencl.so")</span></td>
            </tr>
            <tr>
                <td><strong>⑤ 路由 API 调用</strong></td>
                <td>libOpenCL.so</td>
                <td>你的 <span class="code">clBuildProgram()</span> 调用被路由到对应厂商的实现</td>
            </tr>
            <tr>
                <td><strong>⑥ 厂商驱动执行</strong></td>
                <td>Vendor Driver</td>
                <td>真正的 JIT 编译、GPU 内存管理、任务执行发生在这里</td>
            </tr>
        </tbody>
    </table>

    <h3>2.4 不同平台上的 libOpenCL.so 来源</h3>

    <table class="vendor-table">
        <thead>
            <tr>
                <th>平台</th>
                <th>libOpenCL.so 来源</th>
                <th>对应的 Vendor Driver</th>
                <th>编译责任方</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>NVIDIA GPU</strong></td>
                <td>Khronos 标准 / NVIDIA 提供</td>
                <td><span class="code">libnvidia-opencl.so</span></td>
                <td>NVIDIA</td>
            </tr>
            <tr>
                <td><strong>AMD GPU</strong></td>
                <td>Khronos 标准 / AMD 提供</td>
                <td><span class="code">libamdgpu-core.so</span></td>
                <td>AMD</td>
            </tr>
            <tr>
                <td><strong>Intel GPU</strong></td>
                <td>Khronos 标准 / Intel 提供</td>
                <td><span class="code">libigc.so</span></td>
                <td>Intel</td>
            </tr>
            <tr>
                <td><strong>Linux 通用</strong></td>
                <td>Mesa / Khronos 标准实现</td>
                <td>Vendor-specific</td>
                <td>开源社区 / 厂商</td>
            </tr>
        </tbody>
    </table>

    <div class="note">
        <strong>💡 关键理解：</strong>
        <ul>
            <li><strong>libOpenCL.so 是接口层，不是实现层</strong><br/>
                它只是提供统一的 API 规范，真正的逻辑在厂商驱动中。
            </li>
            <li><strong>ICD 机制的优势</strong><br/>
                支持多个 GPU 同时工作（例如一个系统既有 NVIDIA 又有 AMD 的 GPU）。
            </li>
            <li><strong>JIT 编译发生在 Vendor Driver 中</strong><br/>
                不在 libOpenCL.so 中。你的 kernel 源代码被传递给厂商驱动进行 JIT 编译。
            </li>
            <li><strong>开发者调试建议</strong><br/>
                如果 kernel 编译失败，错误信息来自厂商驱动，不是 libOpenCL.so。
            </li>
        </ul>
    </div>

    <h2>三、手写 Kernel 函数使用 JIT 方式编译</h2>

    <h3>3.1 什么是 JIT 编译？</h3>
    
    <p>
        <strong>JIT（Just-In-Time）编译</strong>是指在程序<strong>运行时</strong>进行编译，而不是预先编译。
        对于 OpenCL Kernel，JIT 编译发生在你调用 <span class="code">clBuildProgram()</span> 时。
    </p>

    <div class="note">
        <strong>✅ 是的，你的手写 Kernel 函数确实通过 JIT 方式由 OpenCL Driver 编译成 GPU 机器码。</strong>
    </div>

    <h3>3.2 Kernel 编译的完整流程</h3>

    <pre class="diagram">
┌──────────────────────────────────────────────────────────────────┐
│ 第一步：你在主机代码中手写 Kernel 字符串                         │
├──────────────────────────────────────────────────────────────────┤
│ const char *kernel_source = R"(                                   │
│   __kernel void add(                                              │
│     __global float *a,                                            │
│     __global float *b,                                            │
│     __global float *c) {                                          │
│       int i = get_global_id(0);                                   │
│       c[i] = a[i] + b[i];                                         │
│     }                                                              │
│ )";                                                               │
└──────────┬───────────────────────────────────────────────────────┘
           │
┌──────────▼───────────────────────────────────────────────────────┐
│ 第二步：创建 Program 对象                                         │
├──────────────────────────────────────────────────────────────────┤
│ cl_program program = clCreateProgramWithSource(                   │
│     context, 1, &kernel_source, NULL, &err);                     │
└──────────┬───────────────────────────────────────────────────────┘
           │
┌──────────▼───────────────────────────────────────────────────────┐
│ 第三步：JIT 编译（运行时发生）⭐ 关键步骤                        │
├──────────────────────────────────────────────────────────────────┤
│ clBuildProgram(program, 1, &device, NULL, NULL, NULL);           │
│                                                                   │
│ 此时 OpenCL Driver 内部会：                                      │
│  1. 解析 OpenCL C 源代码                                         │
│  2. 使用 LLVM 前端转换为中间表示（IR）                           │
│  3. 优化 IR 代码                                                 │
│  4. 生成目标 GPU 的机器码（ISA）                                 │
└──────────┬───────────────────────────────────────────────────────┘
           │
┌──────────▼───────────────────────────────────────────────────────┐
│ 第四步：获取编译后的 Kernel 对象                                  │
├──────────────────────────────────────────────────────────────────┤
│ cl_kernel kernel = clCreateKernel(program, "add", &err);         │
│                                                                   │
│ 现在 kernel 已经是 GPU 可执行的机器码                            │
└──────────┬───────────────────────────────────────────────────────┘
           │
┌──────────▼───────────────────────────────────────────────────────┐
│ 第五步：提交执行                                                   │
├──────────────────────────────────────────────────────────────────┤
│ clEnqueueNDRangeKernel(queue, kernel, 1, NULL,                   │
│                        &global_size, &local_size,                │
│                        0, NULL, NULL);                            │
│                                                                   │
│ GPU 执行机器码                                                   │
└──────────────────────────────────────────────────────────────────┘
    </pre>

    <h3>3.3 JIT 编译的时间开销</h3>

    <table>
        <thead>
            <tr>
                <th>编译阶段</th>
                <th>耗时</th>
                <th>何时发生</th>
                <th>备注</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Host Code 编译</td>
                <td>几秒到几十秒</td>
                <td>开发时（你在电脑上编译）</td>
                <td>只需编译一次，生成可执行文件</td>
            </tr>
            <tr>
                <td><strong>Kernel JIT 编译</strong></td>
                <td><strong>几毫秒到几秒</strong></td>
                <td><strong>程序运行时（第一次调用 clBuildProgram）</strong></td>
                <td><strong>每次运行程序都会重新编译，可以缓存优化</strong></td>
            </tr>
        </tbody>
    </table>

    <h3>3.4 优化 JIT 编译的方法</h3>

    <div class="note">
        <strong>💡 如何减少 JIT 编译的开销：</strong>
        <ul>
            <li><strong>方法 1：编译缓存</strong><br/>
                保存编译后的二进制机器码，下次直接加载
                <span class="code">clCreateProgramWithBinary()</span> 代替 <span class="code">clCreateProgramWithSource()</span>
            </li>
            <li><strong>方法 2：预编译</strong><br/>
                提前编译 Kernel，保存为 SPIR-V 或 PTX 格式
            </li>
            <li><strong>方法 3：优化编译选项</strong><br/>
                在 <span class="code">clBuildProgram()</span> 的 options 参数中指定优化等级
            </li>
            <li><strong>方法 4：lazy 加载</strong><br/>
                只在需要时编译，不要在程序启动时全部编译
            </li>
        </ul>
    </div>

    <h3>3.5 编译链对比</h3>

    <table>
        <thead>
            <tr>
                <th>编译方式</th>
                <th>Host 代码</th>
                <th>Kernel 代码</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>编译时机</strong></td>
                <td>开发期间（AOT - Ahead-of-Time）</td>
                <td>运行时（JIT - Just-In-Time）</td>
            </tr>
            <tr>
                <td><strong>编译器</strong></td>
                <td>GCC / Clang / MSVC</td>
                <td>OpenCL Driver 内置编译器</td>
            </tr>
            <tr>
                <td><strong>输入</strong></td>
                <td>C/C++ 源代码</td>
                <td>OpenCL C 源代码（字符串）</td>
            </tr>
            <tr>
                <td><strong>输出</strong></td>
                <td>CPU 可执行文件 (.exe / ELF)</td>
                <td>GPU 机器码（ISA）</td>
            </tr>
            <tr>
                <td><strong>每次运行是否重新编译</strong></td>
                <td>不重新编译</td>
                <td><strong>是的，每次运行都 JIT 编译</strong>（除非缓存）</td>
            </tr>
        </tbody>
    </table>

    <h2>四、OpenCL Driver 内部结构（以 NVIDIA 为例）</h2>

    <p>
        当你调用 <span class="code">clBuildProgram()</span> 时，OpenCL Driver 内部会经过多个处理阶段。
        以下是 NVIDIA Driver 的内部编译流程：
    </p>

    <table class="driver-table">
        <thead>
            <tr>
                <th>模块</th>
                <th>功能描述</th>
                <th>使用的技术栈</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>① Frontend</strong></td>
                <td>使用 Clang 解析 OpenCL C 源码</td>
                <td>Clang C Compiler</td>
            </tr>
            <tr>
                <td><strong>② Optimizer</strong></td>
                <td>LLVM Pass 优化<br/>- 常量折叠（Constant Folding）<br/>- 循环展开（Loop Unroll）<br/>- 向量化（Vectorization）</td>
                <td>LLVM Optimization Pass</td>
            </tr>
            <tr>
                <td><strong>③ CodeGen</strong></td>
                <td>LLVM TargetMachine 将优化后的中间代码生成为 PTX（Parallel Thread eXecution）</td>
                <td>LLVM TargetMachine</td>
            </tr>
            <tr>
                <td><strong>④ JIT</strong></td>
                <td>PTX 转换为 SASS（Streaming ASSembly）<br/>SASS 是 NVIDIA GPU 真正的机器码</td>
                <td>NVIDIA PTX2SASS Compiler</td>
            </tr>
            <tr>
                <td><strong>⑤ Runtime</strong></td>
                <td>- 调度执行<br/>- 内存管理<br/>- 执行控制<br/>- 结果回传</td>
                <td>NVIDIA Runtime Library</td>
            </tr>
        </tbody>
    </table>

    <h3>4.1 编译流程图（从源代码到 GPU 执行）</h3>

    <pre class="diagram">
┌────────────────────────────────────┐
│   OpenCL C 源代码（字符串）         │
│   __kernel void add(...) {...}     │
└────────────┬─────────────────────┘
             │
    ┌────────▼────────┐
    │  ① Frontend     │
    │  Clang 解析     │
    └────────┬────────┘
             │
        ┌────▼──────────────────────────────┐
        │  AST（抽象语法树）                │
        └────┬──────────────────────────────┘
             │
    ┌────────▼──────────┐
    │  ② Optimizer      │
    │  LLVM Pass        │
    │  - 常量折叠       │
    │  - 循环展开       │
    │  - 向量化         │
    └────────┬──────────┘
             │
        ┌────▼──────────────────────────────┐
        │  优化后的 LLVM IR                 │
        └────┬──────────────────────────────┘
             │
    ┌────────▼──────────────────┐
    │  ③ CodeGen                │
    │  LLVM TargetMachine       │
    └────────┬──────────────────┘
             │
        ┌────▼──────────────────────────────┐
        │  PTX（Parallel Thread eXecution）  │
        │  (NVIDIA 中间汇编代码)             │
        └────┬──────────────────────────────┘
             │
    ┌────────▼──────────────────┐
    │  ④ JIT                    │
    │  PTX2SASS Compiler        │
    └────────┬──────────────────┘
             │
        ┌────▼──────────────────────────────┐
        │  SASS（GPU 机器码）               │
        │  (NVIDIA GPU 真正执行的指令)       │
        └────┬──────────────────────────────┘
             │
    ┌────────▼──────────────────┐
    │  ⑤ Runtime                │
    │  - 分配 GPU 内存           │
    │  - 传输数据                │
    │  - 调度执行                │
    │  - 回传结果                │
    └────────────────────────────┘
             │
        ┌────▼──────────────────────────────┐
        │  GPU 执行 SASS 机器码            │
        │  计算结果返回给 Host               │
        └────────────────────────────────────┘
    </pre>

    <h3>4.2 不同厂商的编译栈对比</h3>

    <table>
        <thead>
            <tr>
                <th>厂商</th>
                <th>Frontend</th>
                <th>Optimizer</th>
                <th>中间表示</th>
                <th>最终 ISA</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>NVIDIA</strong></td>
                <td>Clang</td>
                <td>LLVM Pass</td>
                <td>PTX</td>
                <td>SASS (GPU Machine Code)</td>
            </tr>
            <tr>
                <td><strong>AMD</strong></td>
                <td>Clang</td>
                <td>LLVM Pass</td>
                <td>SPIR-V / LLVM IR</td>
                <td>GCN / RDNA ISA</td>
            </tr>
            <tr>
                <td><strong>Intel</strong></td>
                <td>Clang</td>
                <td>LLVM Pass</td>
                <td>SPIR-V</td>
                <td>Gen ISA</td>
            </tr>
            <tr>
                <td><strong>ARM</strong></td>
                <td>Clang</td>
                <td>LLVM Pass</td>
                <td>SPIR-V</td>
                <td>Mali ISA</td>
            </tr>
            <tr>
                <td><strong>Mesa (Open Source)</strong></td>
                <td>Clang</td>
                <td>LLVM Pass</td>
                <td>SPIR-V / LLVM IR</td>
                <td>对应硬件的 ISA</td>
            </tr>
        </tbody>
    </table>

    <h3>4.3 关键概念解释</h3>

    <div class="note">
        <strong>📌 重要的中间表示和机器码格式：</strong>
        <ul>
            <li>
                <strong>LLVM IR（中间表示）</strong><br/>
                LLVM 的通用中间表示，与硬件无关。所有现代编译器的优化都在这一层进行。
            </li>
            <li>
                <strong>PTX（Parallel Thread eXecution）</strong><br/>
                NVIDIA 专有的中间汇编语言。与具体的 GPU 型号无关，便于跨平台。
            </li>
            <li>
                <strong>SASS（Streaming ASSembly）</strong><br/>
                NVIDIA GPU 真正的机器码。不同 GPU 型号的 SASS 不同（e.g., Maxwell, Pascal, Turing, Ampere）。
            </li>
            <li>
                <strong>SPIR-V（Standard Portable Intermediate Representation）</strong><br/>
                Khronos 定义的通用中间表示，用于 OpenCL、Vulkan 等。支持跨厂商使用。
            </li>
        </ul>
    </div>

    <h3>4.4 为什么要这样设计？</h3>

    <div class="note">
        <strong>💡 设计原理：</strong>
        <ul>
            <li>
                <strong>分层设计的好处</strong><br/>
                前端（解析）、优化（LLVM Pass）、代码生成（CodeGen）分离，
                使得支持新硬件时只需要修改 CodeGen 部分，优化逻辑可以复用。
            </li>
            <li>
                <strong>中间表示的价值</strong><br/>
                PTX / SPIR-V 作为中间表示，一次编译可以支持多个 GPU 型号和版本。
                例如同一份 PTX 代码可以运行在 Tesla T4、V100、H100 上。
            </li>
            <li>
                <strong>JIT 的权衡</strong><br/>
                从 PTX → SASS 的 JIT 编译很快（几十毫秒），
                而整个 Frontend + Optimizer 的编译可能需要数秒。
            </li>
        </ul>
    </div>
